Cache-Control的特性：
    .可缓存性：
        . public
            在http请求返回的过程中，如果在Cache-Control里面设置了public值，
            则代表http请求返回的内容，所经过的任何路径，包括http的代理服务器以及发出这个http请求
            的客户端-浏览器，都可以对返回的内容进行缓存操作。

            所谓缓存，就是把请求返回的数据存在本地，下次可以直接读取缓存数据去使用，而不需要再次请求返回这个
            数据的服务器。

            在网络中，代理服务器以及客户端都可以进行缓存操作。
            而它的可缓存性就是指定哪些地方可以进行缓存。
            
            public就是说这个http返回内容经过的任何地方都可以进行缓存。
        
        . private
            代表，只有发起请求的浏览器才能进行缓存操作。

        . no-cache
            代表，本地客户端和代理服务器可以进行缓存，但是这个缓存首先必须到服务器那边进行“验证”之后，
            才能使用这些缓存。---见第5节：缓存验证Last-Modified和Etag的使用

        . no-store    
            代表，客户端和本地都不可以进行缓存操作。

    . 到期
        . 设置缓存何时到期，最常用的就是 max-age
            浏览器会读取max-age作为缓存的到期时间
        . s-maxage 
            s-maxage 是专门为代理服务器设置的，
            也就是说代理服务器上缓存的到期时间是以s-maxage为准的。
        . max-stale   
            在max-age过期之后，max-stale是浏览器在发起请求时会主动携带的一个头部信息。
            代表，即便缓存已经过期，在max-stale这个时间内，它还可以继续使用过期的缓存，
            而不需要去服务器那边请求新的内容。

            max-stale在浏览器中是用不到的，因为浏览器的发起请求以及静态资源请求的过程中，
            它并不会主动给我们设置这个头，且这个头只有在发起端设置才有用，在服务端返回的内容
            中去设置不会有任何作用。

    . 重新验证      
        . must-revalidate
          代表，在设置了max-age的缓存当中，如果缓存已经过期， 则必须去原服务端发起这部分请求，
          然后重新获取数据。而不能直接使用本地缓存。
        . proxy-revalidate
           专门用在缓存服务器当中的，必须指定缓存服务器在缓存过期后，必须要去原服务器重新请求一遍，
           而不能直接使用本地缓存。

         这两个在我们浏览器当中基本不会用到，大家只要知道它的意思就可以。
         

  强调：这些头只是限制性的，声明性的，没有任何强制约束力。

  重点来了：
        
        实际演示代码在 code/cache-control目录下:

       当我们在响应中添加了'Cache-Control:max-age=20'这个头之后，我们再次刷新时，在调试Network里，
        1. script.js的Size变成了memory cache
        2. 而且 Time 变成了 0

        这表示script.js再次请求是直接从本地缓存中读取的，无任何网络延迟。

        这就是Cache-Control的作用：让我们在请求资源的时候，可以从缓存中去读。


       3.当我们服务端返回的内容有改变时，因为它请求的url没有发生变化，所以它依然只会从缓存里面去读取内容。而没有去服务端加载新的script.js文件。
        
        Cache-Control 是一个客户端缓存， 如果我们设置了Cache-Control，它就直接在客户端缓存了，根本不经过服务端的验证。
        所以在服务端更新了文件之后，客户端并不能感知服务端的文件是否更新，所以它还是去缓存去读，
        就导致静态资源在服务端更新之后，没有及时的更新到客户端这个问题。这是我们在前端开发时常见的问题。
        
        我们希望浏览器去缓存我们的静态资源文件（css,js,图片），因为这样再次打开网站时，加载速度就会变的非常快。
        但是我们又不希望服务端在更新了静态资源之后，客户端依然是请求的老的缓存中的资源。

        4.常见的前端解决方案就是：
          . 根据打包完成的文件，依据更改内容的变化生成一段哈希码，加在文件名上。
            因为这个哈希码是依然内容的变化来自动计算，如果内容没有改动，则哈希码不会变化。
            反应到页面上就是url没有发生变化。
            而如果你的内容有变化，则哈希码会变化，则对应到的url也会有变化，
            url变化之后，则发起的请求就是一个新的请求，而不是之前缓存在浏览器中的静态资源请求。
            这样就可以达到一个更新缓存的目的。

            这是目前业界刷新浏览器缓存的通用的方案。





